View(variables_per_week_foundation)
View(posts)
View(variables_per_week_foundation)
posts %>% select(uid == 1) %>% arrange(week_since_foundation) %>% select(week_since_reg, week_since_foundation, dateline)
posts %>% filter(uid == 1) %>% arrange(week_since_foundation) %>% select(week_since_reg, week_since_foundation, dateline)
posts %>% filter(uid == 2) %>% arrange(week_since_foundation) %>% select(week_since_reg, week_since_foundation, dateline)
posts %>% filter(uid == 2) %>% arrange(regdate) %>% select(uid, username)
posts %>% arrange(regdate) %>% select(uid, username)
suers %>% arrange(regdate) %>% select(uid, username)
users %>% arrange(regdate) %>% select(uid, username)
posts %>% filter(min(dateline)) %>% select(uid, username, dateline)
posts %>% slice_min(dateline) %>% select(uid, username, dateline)
posts %>%  filter(uid == 1) %>% slice_min(dateline) %>% pull(dateline) (posts %>% slice_min(dateline) %>% select(uid, username, dateline) %>%  pull(dateline))
(posts %>%  filter(uid == 1) %>% slice_min(dateline) %>% pull(dateline) - (posts %>% slice_min(dateline) %>% select(uid, username, dateline) %>%  pull(dateline)))/604800
View(variables_per_week_foundation)
View(variables_per_week_reg)
(posts %>%  filter(uid == 1) %>% pull(regdate) - (posts %>% slice_min(dateline) %>% select(uid, username, dateline) %>%  pull(dateline)))/604800
(users %>%  filter(uid == 1) %>% pull(regdate) - (posts %>% slice_min(dateline) %>% select(uid, username, dateline) %>%  pull(dateline)))/604800
( (posts %>% slice_min(dateline) %>% select(uid, username, dateline) %>%  pull(dateline))- (users %>%  filter(uid == 1) %>% pull(regdate)))/604800
( (posts %>% filter(uid == 1) %>% slice_min(dateline) %>% pull(dateline))- (users %>%  filter(uid == 1) %>% pull(regdate)))/604800
View(posts)
View(users)
users %>% filter(was_banned == FALSE, has_warning_points == FALSE, has_avatar == TRUE, more_500_thx == TRUE, given_100_thx == TRUE,range_diff_forums == TRUE, request_fulfilled != 0) %>% nrow()
library(tidyverse)
users %>% filter(was_banned == FALSE, has_warning_points == FALSE, has_avatar == TRUE, more_500_thx == TRUE, given_100_thx == TRUE,range_diff_forums == TRUE, request_fulfilled != 0) %>% nrow()
users %>% filter(was_banned == FALSE, has_warning_points == FALSE, has_avatar == TRUE, more_500_thx == TRUE, given_100_thx == TRUE,range_diff_forums == TRUE, users$request_fulfilled != 0) %>% nrow()
View(users)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
#6. must have fulfilled at least one request
tid_fulfilled_requests <- posts %>%
filter(fid == 124| fid == 77 | fid == 78 | fid == 144) %>% #these fora handle requests
select(uid, message, subject,dateline, tid) %>%
filter(str_detect(subject, "\\[Completed\\]")) %>% #we want to grab requests that have been answered: "[Completed]" is used in the subject to indicate finished requests.
pull(tid)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
fulfilled <- read_csv("../out/fulfilled_1.csv") %>% bind_rows(read_csv("../out/fulfilled_2.csv")) %>% mutate(fulfilled = case_when(fulfilled == 0 ~ FALSE, .default = TRUE)) %>% rename(request_fulfilled = fulfilled)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
posts <- full_join(posts, fulfilled %>% select(pid, request_fulfilled), by = "pid")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
posts <- mutate(posts, request_fulfilled = case_when(is.na(request_fulfilled) ~ 0, .default =request_fulfilled))
users %>% colnames()
#Clean up
rm(time_to_MVP_appl, last_appl, diff_fora_with_link_posted, fulfilled, mvp_id, appl_id)
-Same a above but differentiated by subforum topic (for instance, do posts in the security forum contribute to the likelihood of getting MVP status, or only posts to sexual subforums; do posts in the ‘soft’ categories contribute as much as those in the ‘hardcore’ categories; also, posts in nonsexual subforums – other than security – might signal individuals driven by social rather than sexual motives)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
#username and uids of users who applies for MVP roles
appl_id <- posts %>% filter(fid == 146 & replyto == 0) %>% select(uid, username) %>% distinct_all()
#username and uid of users who have mvp status, according to group memberships.
mvp_id <- users %>% filter(usergroup == 13 | str_detect(additionalgroups, "13")) %>% select(uid, username)
#We checked whether it made a difference to filter for uid or username and it did not. Here we create a logical vector indicating who applied for MVP role. and add it to the tibble.
users <- users %>% mutate(applied_for_MVP = (users %>% pull(uid)) %in% (appl_id %>% pull(uid)))
#the same holds true for having MVP status. We add a logicla vector to the tibble indicating whether a user has MVP status.
users <- users %>% mutate(MVP = (users %>% pull(uid)) %in% (mvp_id %>% pull(uid)))
#1. followed rules --> not on banlist & no warning points
users <- users %>%
mutate(was_banned = (users %>% pull(uid)) %in% (read.delim("../data/child_banned.csv", sep="|") %>% as_tibble() %>% pull(uid)),
has_warning_points = case_when(warningpoints > 0 ~ TRUE,
.default = FALSE))
#2. has avatar
users <- users %>% mutate(has_avatar = !(users %>% pull(avatar) %>% na_if("") %>% is.na()))
#3. at least member for 3 months (can only check how long application is in the past)
last_appl <- posts %>%
filter(fid == 146 & replyto == 0) %>%
group_by(uid) %>% summarise(dateline = max(dateline)) %>% ungroup()
time_to_MVP_appl <- last_appl %>%
left_join(users %>% select(uid, regdate), by="uid") %>%
mutate(time_to_MVP_appl = dateline - regdate) %>%
select(uid, time_to_MVP_appl)
users <- users %>% full_join(time_to_MVP_appl, by="uid")
users <- users %>% mutate(time_to_MVP_appl = time_to_MVP_appl/2628000)
users <- users %>% mutate(three_months_since_reg = case_when(time_to_MVP_appl > 3 ~ TRUE, time_to_MVP_appl < 3 ~ FALSE, .default = NA))
#4.1. 500 thanks received
users <- users %>% mutate(more_500_thx= case_when(tyl_unumrcvtyls >= 500 ~ TRUE, .default = FALSE))
#4.2  100 thanks given
users <- users %>% mutate(given_100_thx = case_when(tyl_unumtyls >= 100 ~ TRUE, .default = FALSE))
#5. posted content over a range of fora
#First we create a new variable where we remove all quotes, so that we do not accidentally count any links that are just quotes from other users.
posts <- posts %>% mutate(quote_removed_message = str_remove(message, "\\[quote(?s).*quote\\]"))
diff_fora_with_link_posted <- posts %>% filter(str_detect(posts$quote_removed_message, "http") & replyto == 0) %>% select(uid, fid) %>% group_by(uid) %>% summarise(n_fora = n_distinct(fid))
users <- users %>%
full_join(diff_fora_with_link_posted, by="uid") %>%
rename(diff_fora_with_link_posted = n_fora) %>%
mutate(diff_fora_with_link_posted = case_when(!is.na(diff_fora_with_link_posted) ~ diff_fora_with_link_posted, .default = 0))
#What does 'range of different forums' mean? Here we allow all users who have posted in more than one forum but that is rather lax - we can assess later in how many fora the actual MVPs have posted.
users <- users %>% mutate(range_diff_forums = case_when(diff_fora_with_link_posted > 2 ~ TRUE, .default = FALSE))
#6. must have fulfilled at least one request
tid_fulfilled_requests <- posts %>%
filter(fid == 124| fid == 77 | fid == 78 | fid == 144) %>% #these fora handle requests
select(uid, message, subject,dateline, tid) %>%
filter(str_detect(subject, "\\[Completed\\]")) %>% #we want to grab requests that have been answered: "[Completed]" is used in the subject to indicate finished requests.
pull(tid)
#Used as base for manual coding of fulfilled requests.
#posts %>% filter(posts$tid %in% tid_fulfilled_requests) %>% filter(str_detect(subject, "RE")) %>% select(pid, tid,dateline, message) %>% arrange(tid, dateline) %>% mutate(message = message %>% str_remove("\\[quote(?s).*quote\\]")) %>% filter(str_detect(message, "http"))
fulfilled <- read_csv("../out/fulfilled_1.csv") %>% bind_rows(read_csv("../out/fulfilled_2.csv")) %>% mutate(fulfilled = case_when(fulfilled == 0 ~ FALSE, .default = TRUE)) %>% rename(request_fulfilled = fulfilled)
posts <- full_join(posts, fulfilled %>% select(pid, request_fulfilled), by = "pid")
posts <- mutate(posts, request_fulfilled = case_when(is.na(request_fulfilled) ~ 0, .default =request_fulfilled))
#Clean up
rm(time_to_MVP_appl, last_appl, diff_fora_with_link_posted, fulfilled, mvp_id, appl_id)
knitr::opts_chunk$set(echo = TRUE)
posts <- posts %>% mutate(n_char = lapply(posts$quote_removed_message, function(x) stringi::stri_length(x) - stri_count_fixed(x, " ")) %>% unlist())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#import data
forums <- read.delim("../data/child_forums.csv", sep="|") %>% as_tibble()
users <- read.delim("../data/child_users.csv", sep="|") %>% as_tibble()
posts <- read.delim("../data/child_posts.csv", sep="|") %>% as_tibble()
#username and uids of users who applies for MVP roles
appl_id <- posts %>% filter(fid == 146 & replyto == 0) %>% select(uid, username) %>% distinct_all()
#username and uid of users who have mvp status, according to group memberships.
mvp_id <- users %>% filter(usergroup == 13 | str_detect(additionalgroups, "13")) %>% select(uid, username)
#We checked whether it made a difference to filter for uid or username and it did not. Here we create a logical vector indicating who applied for MVP role. and add it to the tibble.
users <- users %>% mutate(applied_for_MVP = (users %>% pull(uid)) %in% (appl_id %>% pull(uid)))
#the same holds true for having MVP status. We add a logicla vector to the tibble indicating whether a user has MVP status.
users <- users %>% mutate(MVP = (users %>% pull(uid)) %in% (mvp_id %>% pull(uid)))
#1. followed rules --> not on banlist & no warning points
users <- users %>%
mutate(was_banned = (users %>% pull(uid)) %in% (read.delim("../data/child_banned.csv", sep="|") %>% as_tibble() %>% pull(uid)),
has_warning_points = case_when(warningpoints > 0 ~ TRUE,
.default = FALSE))
#2. has avatar
users <- users %>% mutate(has_avatar = !(users %>% pull(avatar) %>% na_if("") %>% is.na()))
#3. at least member for 3 months (can only check how long application is in the past)
last_appl <- posts %>%
filter(fid == 146 & replyto == 0) %>%
group_by(uid) %>% summarise(dateline = max(dateline)) %>% ungroup()
time_to_MVP_appl <- last_appl %>%
left_join(users %>% select(uid, regdate), by="uid") %>%
mutate(time_to_MVP_appl = dateline - regdate) %>%
select(uid, time_to_MVP_appl)
users <- users %>% full_join(time_to_MVP_appl, by="uid")
users <- users %>% mutate(time_to_MVP_appl = time_to_MVP_appl/2628000)
users <- users %>% mutate(three_months_since_reg = case_when(time_to_MVP_appl > 3 ~ TRUE, time_to_MVP_appl < 3 ~ FALSE, .default = NA))
#4.1. 500 thanks received
users <- users %>% mutate(more_500_thx= case_when(tyl_unumrcvtyls >= 500 ~ TRUE, .default = FALSE))
#4.2  100 thanks given
users <- users %>% mutate(given_100_thx = case_when(tyl_unumtyls >= 100 ~ TRUE, .default = FALSE))
#5. posted content over a range of fora
#First we create a new variable where we remove all quotes, so that we do not accidentally count any links that are just quotes from other users.
posts <- posts %>% mutate(quote_removed_message = str_remove(message, "\\[quote(?s).*quote\\]"))
diff_fora_with_link_posted <- posts %>% filter(str_detect(posts$quote_removed_message, "http") & replyto == 0) %>% select(uid, fid) %>% group_by(uid) %>% summarise(n_fora = n_distinct(fid))
users <- users %>%
full_join(diff_fora_with_link_posted, by="uid") %>%
rename(diff_fora_with_link_posted = n_fora) %>%
mutate(diff_fora_with_link_posted = case_when(!is.na(diff_fora_with_link_posted) ~ diff_fora_with_link_posted, .default = 0))
#What does 'range of different forums' mean? Here we allow all users who have posted in more than one forum but that is rather lax - we can assess later in how many fora the actual MVPs have posted.
users <- users %>% mutate(range_diff_forums = case_when(diff_fora_with_link_posted > 2 ~ TRUE, .default = FALSE))
#6. must have fulfilled at least one request
tid_fulfilled_requests <- posts %>%
filter(fid == 124| fid == 77 | fid == 78 | fid == 144) %>% #these fora handle requests
select(uid, message, subject,dateline, tid) %>%
filter(str_detect(subject, "\\[Completed\\]")) %>% #we want to grab requests that have been answered: "[Completed]" is used in the subject to indicate finished requests.
pull(tid)
#Used as base for manual coding of fulfilled requests.
#posts %>% filter(posts$tid %in% tid_fulfilled_requests) %>% filter(str_detect(subject, "RE")) %>% select(pid, tid,dateline, message) %>% arrange(tid, dateline) %>% mutate(message = message %>% str_remove("\\[quote(?s).*quote\\]")) %>% filter(str_detect(message, "http"))
fulfilled <- read_csv("../out/fulfilled_1.csv") %>% bind_rows(read_csv("../out/fulfilled_2.csv")) %>% mutate(fulfilled = case_when(fulfilled == 0 ~ FALSE, .default = TRUE)) %>% rename(request_fulfilled = fulfilled)
posts <- full_join(posts, fulfilled %>% select(pid, request_fulfilled), by = "pid")
posts <- mutate(posts, request_fulfilled = case_when(is.na(request_fulfilled) ~ 0, .default =request_fulfilled))
#Clean up
rm(time_to_MVP_appl, last_appl, diff_fora_with_link_posted, fulfilled, mvp_id, appl_id)
knitr::opts_chunk$set(echo = TRUE)
posts <- posts %>% mutate(n_char = lapply(posts$quote_removed_message, function(x) stringi::stri_length(x) - stringi::stri_count_fixed(x, " ")) %>% unlist())
posts <- posts %>% mutate(n_words = str_count(quote_removed_message, '\\w+'))
#First we exclude uid zero because it refers to multiple usernames (probably deleted ones).
posts <- posts %>% filter(uid != 0)
#We group all posts by user ID, then select the earliest post per user. Because some posts are duplicated or edited, we use a tie breaker which just selects the first post in the table.
first_post <- posts %>%
group_by(uid) %>%
slice_min(order_by = dateline, with_ties=FALSE) %>% #get the first post of every person
select(uid, pid, dateline) %>% #select only relevant columns
rename(first_post = dateline, first_pid = pid) #rename datline to first post
last_post <- posts %>%
group_by(uid) %>%
slice_max(order_by = dateline, with_ties=FALSE) %>% #get the last post per person
select(uid,pid,  dateline) %>% #select only relevant columns
rename(last_post = dateline, last_pid = pid) #rename dateline to last post
users <- users %>% full_join(first_post, by="uid") %>% full_join(last_post, by="uid")#combine information on the first post made, with the users dataframe. Many users have no first post.
#Code to check whether the uids in first post are unique
#posts[posts$pid %in% first_post[(first_post$uid %in% (first_post %>% filter(duplicated(uid)) %>% pull(uid))),]$pid,] %>% select(fid, uid, pid, message, edittime)
#we add two measures of the time people were active to the data. First the time between a user's first and last post (time.active.post), then the time between a user's registration on the forum and their last visit (time.active).
users <- users %>% mutate(time_active_post = last_post - first_post, time_active = lastvisit - regdate)
#add total number of posts per uid to the data
users <- users %>% left_join(posts %>% group_by(uid) %>% summarise(num_post = n()), by = "uid")
#we add a variable with the total number of posts with html links to the data frame. First we make sure that no cited links are counted.
users <- users %>%
full_join(posts %>%
filter(str_detect(quote_removed_message, "http") & replyto == 0) %>% #we exclude replies and search in the messages with quotes removed for html-links. Eyeballing reveals that it is practically always CSEM.
select(uid, fid, quote_removed_message) %>% #we select relevant variables
group_by(uid) %>%
summarise(n_posts_link = n()), by="uid") #and count all messages per person
#First we convert the dateline column to weeks
posts <- posts %>%
mutate(dateline_weeks = dateline/604800) %>% #we convert the dateline format into weeks
left_join(users %>% select(uid, regdate), by= "uid") %>% #we add the regdate of every user
mutate(regdate = regdate/604800,  #we transform regdate into weeks
regdate_warhead = ((users %>%
filter(uid == 1) %>%
pull(regdate))/604800) %>%
rep(times = nrow(posts))) %>% #We add warheads regdate as a marker of the foundation of the forum
mutate(week_since_reg = dateline_weeks - regdate +1 , #we create a variable that tranforms the dateline variable into weeks since regdate for every user
week_since_foundation = dateline_weeks - regdate_warhead +1) %>% #we create a variable that counts weeks since the Warheads registration
select(-regdate_warhead, -regdate) %>%  #we remove the helper variables that encode a lot of redundant information
mutate(week_since_reg = trunc(week_since_reg), week_since_foundation = trunc(week_since_foundation)) # transform the variables to whole weeks
#We create average posts per week variables. Once with the time of active posting, once with the time from registration to last visit as reference. We divide the time by 604800 because that is the average number of seconds per week.
users <- users %>% group_by(uid) %>% mutate(avg_post_last_post = num_post/(time_active_post/604800), avg_post_active = num_post/(time_active/604800))
#We create num of post per week. One frame that takes the weeks since regdata and one frame that takes the weeks since foundation of the forum.
variables_per_week_reg <- posts %>%
group_by(uid, week_since_reg) %>% #We group by uid and week_since_reg so that we can compute quantities per week since regdate.
summarise(n_post = n(), #we compute sum of posts, number of characters, number of words, thankyou likes received per week.
n_char = sum(n_char),
n_words = sum(n_words),
tyl = sum(tyl_pnumtyls),
n_subfora = n_distinct(fid)) %>%
left_join(posts %>%
filter(str_detect(quote_removed_message, "http")) %>% #we access posts with links in which no quote is still left in the post
group_by(uid, week_since_reg) %>%
summarise(n_posts_w_links = n()), by=join_by(uid, week_since_reg)) %>% #we count the number of post with link per week and join it with the variables_per_week_reg tibble
mutate(n_posts_w_links = case_when(is.na(n_posts_w_links) ~ 0, .default = n_posts_w_links)) %>%  #we want the default of the variable be zero and not NA.
ungroup()
variables_per_week_foundation <- posts %>%
group_by(uid, week_since_foundation) %>% #We group by uid and week_since_reg so that we can compute quantities per week since regdate.
summarise(n_post = n(), #we compute sum of posts, number of characters, number of words, thankyou likes received per week.
n_char = sum(n_char),
n_words = sum(n_words),
tyl = sum(tyl_pnumtyls),
n_subfora = n_distinct(fid)) %>%
left_join(posts %>%
filter(str_detect(quote_removed_message, "http")) %>% #we access posts with links in which no quote is still left in the post
group_by(uid, week_since_foundation) %>%
summarise(n_posts_w_links = n()), by=join_by(uid, week_since_foundation)) %>% #we count the number of post with link per week and join it with the variables_per_week_reg tibble
mutate(n_posts_w_links = case_when(is.na(n_posts_w_links) ~ 0, .default = n_posts_w_links)) %>%
ungroup()
users %>% colnameS()
users %>% colnames()
packages <- c("tidyverse", "readr", "ggpubr")
lapply(packages, require, character.only=T)
rm(packages)
##data & environment
load(".RData")
data_females <- haven::read_spss("./data/dataE_clear5 2209.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 1) %>%
dplyr::select(-gender)
plotd_m <- data_males %>% pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
plotd_m <- data_males %>% pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
data_females <- haven::read_spss("./data/dataE_clear5 2209.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 1) %>%
dplyr::select(-gender)
setwd("C:/Users/Rebecca/Documents/GitHub/LPA_analysis/total sample's analysis")
data_females <- haven::read_spss("./data/dataE_clear5 2209.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 1) %>%
dplyr::select(-gender)
##2 = male gender
data_males <- haven::read_spss("./data/dataE_clear5 2209.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 2) %>%
dplyr::select(-gender)
##data & environment
load(".RData") #load a pre-saved .RData file in which the environment is saved
plotd_m <- data_males %>% pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
##create a table with the quantiles for each variable
quant_m <- as.data.frame(t(do.call(rbind.data.frame, (lapply(c(
"CSBD", "lon", "meffort", "mvalue", "PPCS_6", "sexdrive2", "socialanx"), function(x){
parse_number(gsub(",.*$", "", levels(cut_number(as.data.frame(data_males)[, x], 4))))})))))
##rename columns
colnames(quant_m) <- c("CSBD", "lon", "meffort", "mvalue", "PPCS_6", "sexdrive2", "socialanx")
##pivot for plotting
quant_m <- pivot_longer(quant_m, cols=CSBD:socialanx, names_to='var')
##call on function in other R script
source("./functions/flat_violin.R")
ggplot(plotd_m %>% filter(var!="attr"), aes(x=as.factor(var), y=score, fill=var)) +
geom_flat_violin(scale="width") +
scale_fill_grey(start=.5, end=.9, aesthetics = "fill") +
geom_dotplot(binaxis="y", dotsize=.04, stackdir="down", binwidth=.3, position=position_nudge(-.025)) +
geom_errorbar(data=quant_m, aes(x=as.factor(var), ymin=value, ymax=value, linetype="Quantiles"),
inherit.aes=F, linewidth=.5, width=.3, position=position_nudge(x=.15)) +
scale_linetype_manual(values="solid") +
guides(linetype=guide_legend(""), fill="none") +
scale_x_discrete(labels=NULL) +
labs(x="", y="Value") +
theme_classic() +
theme(axis.text.x=element_text(angle=45, hjust=1, size=10))
m1 <- ggplot(plotd_m %>% filter(var!="attr"), aes(x=as.factor(var), y=score, fill=var)) +
geom_flat_violin(scale="width") +
scale_fill_grey(start=.5, end=.9, aesthetics = "fill") +
geom_dotplot(binaxis="y", dotsize=.04, stackdir="down", binwidth=.3, position=position_nudge(-.025)) +
geom_errorbar(data=quant_m, aes(x=as.factor(var), ymin=value, ymax=value, linetype="Quantiles"),
inherit.aes=F, linewidth=.5, width=.3, position=position_nudge(x=.15)) +
scale_linetype_manual(values="solid") +
guides(linetype=guide_legend(""), fill="none") +
scale_x_discrete(labels=NULL) +
labs(x="", y="Value") +
theme_classic() +
theme(axis.text.x=element_text(angle=45, hjust=1, size=10))
##plot attraction to children separately
m2 <- ggplot(plotd_m %>% filter(var=="attr"), aes(x=score)) +
geom_bar() +
theme_classic() +
labs(x="", y="Count")
#Violin plots females ----
##create long data frame for plotting, including only the relevant variables
plotd_f <- data_females %>% select(CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
##create a table with the quantiles for each variable (except CSBD & PPCS_6)
quant_f <- as.data.frame(t(do.call(rbind.data.frame, (lapply(c("lon", "meffort", "mvalue", "sexdrive2", "socialanx"),
function(x){parse_number(gsub(",.*$", "", levels(cut_number(
as.data.frame(data_females)[, x], 4))))})))))
##rename columns
colnames(quant_f) <- c("lon", "meffort", "mvalue", "sexdrive2", "socialanx")
##pivot for plotting
quant_f <- pivot_longer(quant_f, cols=lon:socialanx, names_to='var')
##add CSBD & PPCS_6 manually because they can only be dichotomised
quant_f <- rbind(quant_f, pivot_longer(as.data.frame(t(do.call(rbind.data.frame,
(lapply(c("CSBD", "PPCS_6"), function(x){
parse_number(gsub(",.*$", "",levels(cut_number(as.data.frame(
data_females)[, x], 2))))}))))), cols=V1:V2, names_to='var'))
##rename variables
quant_f$var[quant_f$var=="V1"] <- "CSBD"
quant_f$var[quant_f$var=="V2"] <- "PPCS_6"
##plot
f1 <- ggplot(plotd_f %>% filter(var!="attr"), aes(x=as.factor(var), y=score, fill=var)) +
geom_flat_violin(scale="width") +
scale_fill_grey(start=.5, end=.9, aesthetics = "fill") +
geom_dotplot(binaxis="y", dotsize=.04, stackdir="down", binwidth=.3, position=position_nudge(-.025)) +
geom_errorbar(data=quant_f, aes(x=as.factor(var), ymin=value, ymax=value, linetype="Quantiles"),
inherit.aes=F, linewidth=.5, width=.3, position=position_nudge(x=.15)) +
scale_linetype_manual(values="solid") +
guides(linetype=guide_legend(""), fill="none") +
scale_x_discrete(labels=c("CSBD"="Compulsive sex.", "lon"="Loneliness", "meffort"="Mating effort", "mvalue"="Mate value",
"PPCS_6"="Probl. porn use", "sexdrive2"="Sex drive", "socialanx"="Social anxiety")) +
labs(x="", y="Value") +
theme_classic() +
theme(axis.text.x=element_text(angle=45, hjust=1, size=10))
##plot attraction to children separately
f2 <- ggplot(plotd_f %>% filter(var=="attr"), aes(x=score)) +
geom_bar() +
theme_classic() +
labs(x="Attraction to children", y="Count")
#Arrange violin plots together ----
mf1 <- ggarrange(m1, f1, nrow=2, align="v",
labels=c('a)', 'b)'), font.label=list(size=12, face='plain'), vjust=c(1, 0),
common.legend=T, legend='right')
mf2 <- ggarrange(m2, f2, nrow=2, align="v",
common.legend=T, legend='right')
ggarrange(mf1, mf2, ncol=2, align='h')
#Violin plots males ----
##create long data frame for plotting, including only the relevant variables
plotd_m <- data_males %>% pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
View(plotd_m)
mean(data_males$meffort)
data_females <- haven::read_spss("./data/dataE_2112.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 1) %>%
dplyr::select(-gender)
mean(data_females$meffort)
data_females <- haven::read_spss("./data/dataE_2112.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 1) %>%
dplyr::select(-gender)
##2 = male gender
data_males <- haven::read_spss("./data/dataE_2112.sav") %>%
dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
filter(gender == 2) %>%
dplyr::select(-gender)
plotd_m <- data_males %>% pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
##create a table with the quantiles for each variable
quant_m <- as.data.frame(t(do.call(rbind.data.frame, (lapply(c(
"CSBD", "lon", "meffort", "mvalue", "PPCS_6", "sexdrive2", "socialanx"), function(x){
parse_number(gsub(",.*$", "", levels(cut_number(as.data.frame(data_males)[, x], 4))))})))))
##rename columns
colnames(quant_m) <- c("CSBD", "lon", "meffort", "mvalue", "PPCS_6", "sexdrive2", "socialanx")
##pivot for plotting
quant_m <- pivot_longer(quant_m, cols=CSBD:socialanx, names_to='var')
##call on function in other R script
source("./functions/flat_violin.R")
##plot
m1 <- ggplot(plotd_m %>% filter(var!="attr"), aes(x=as.factor(var), y=score, fill=var)) +
geom_flat_violin(scale="width") +
scale_fill_grey(start=.5, end=.9, aesthetics = "fill") +
geom_dotplot(binaxis="y", dotsize=.04, stackdir="down", binwidth=.3, position=position_nudge(-.025)) +
geom_errorbar(data=quant_m, aes(x=as.factor(var), ymin=value, ymax=value, linetype="Quantiles"),
inherit.aes=F, linewidth=.5, width=.3, position=position_nudge(x=.15)) +
scale_linetype_manual(values="solid") +
guides(linetype=guide_legend(""), fill="none") +
scale_x_discrete(labels=NULL) +
labs(x="", y="Value") +
theme_classic() +
theme(axis.text.x=element_text(angle=45, hjust=1, size=10))
##plot attraction to children separately
m2 <- ggplot(plotd_m %>% filter(var=="attr"), aes(x=score)) +
geom_bar() +
theme_classic() +
labs(x="", y="Count")
#Violin plots females ----
##create long data frame for plotting, including only the relevant variables
plotd_f <- data_females %>% select(CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>%
pivot_longer(cols=sexdrive2:attr, names_to="var", values_to="score")
##create a table with the quantiles for each variable (except CSBD & PPCS_6)
quant_f <- as.data.frame(t(do.call(rbind.data.frame, (lapply(c("lon", "meffort", "mvalue", "sexdrive2", "socialanx"),
function(x){parse_number(gsub(",.*$", "", levels(cut_number(
as.data.frame(data_females)[, x], 4))))})))))
##rename columns
colnames(quant_f) <- c("lon", "meffort", "mvalue", "sexdrive2", "socialanx")
##pivot for plotting
quant_f <- pivot_longer(quant_f, cols=lon:socialanx, names_to='var')
##add CSBD & PPCS_6 manually because they can only be dichotomised
quant_f <- rbind(quant_f, pivot_longer(as.data.frame(t(do.call(rbind.data.frame,
(lapply(c("CSBD", "PPCS_6"), function(x){
parse_number(gsub(",.*$", "",levels(cut_number(as.data.frame(
data_females)[, x], 2))))}))))), cols=V1:V2, names_to='var'))
##rename variables
quant_f$var[quant_f$var=="V1"] <- "CSBD"
quant_f$var[quant_f$var=="V2"] <- "PPCS_6"
##plot
f1 <- ggplot(plotd_f %>% filter(var!="attr"), aes(x=as.factor(var), y=score, fill=var)) +
geom_flat_violin(scale="width") +
scale_fill_grey(start=.5, end=.9, aesthetics = "fill") +
geom_dotplot(binaxis="y", dotsize=.04, stackdir="down", binwidth=.3, position=position_nudge(-.025)) +
geom_errorbar(data=quant_f, aes(x=as.factor(var), ymin=value, ymax=value, linetype="Quantiles"),
inherit.aes=F, linewidth=.5, width=.3, position=position_nudge(x=.15)) +
scale_linetype_manual(values="solid") +
guides(linetype=guide_legend(""), fill="none") +
scale_x_discrete(labels=c("CSBD"="Compulsive sex.", "lon"="Loneliness", "meffort"="Mating effort", "mvalue"="Mate value",
"PPCS_6"="Probl. porn use", "sexdrive2"="Sex drive", "socialanx"="Social anxiety")) +
labs(x="", y="Value") +
theme_classic() +
theme(axis.text.x=element_text(angle=45, hjust=1, size=10))
##plot attraction to children separately
f2 <- ggplot(plotd_f %>% filter(var=="attr"), aes(x=score)) +
geom_bar() +
theme_classic() +
labs(x="Attraction to children", y="Count")
#Arrange violin plots together ----
mf1 <- ggarrange(m1, f1, nrow=2, align="v",
labels=c('a)', 'b)'), font.label=list(size=12, face='plain'), vjust=c(1, 0),
common.legend=T, legend='right')
mf2 <- ggarrange(m2, f2, nrow=2, align="v",
common.legend=T, legend='right')
ggarrange(mf1, mf2, ncol=2, align='h')
knitr::opts_chunk$set(echo=F, warning=F, message=F)
library(tidyverse)
data_m <- haven::read_spss("./data/dataE_2112.sav") %>% dplyr::select(CASE, gender, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr, starts_with("Y") & ends_with("r") & !ends_with("YP_r")) %>% #remove YP items
filter(gender == 2) %>% dplyr::select(-gender)
# creating correlation matrix
corr_mat_m <- round(cor(data_m %>% select(-CASE), method="spearman"), 2)
colnames(corr_mat_m) <- c("Sex drive", "Compulsive sex.", "Probl. porn use", "Mating effort", "Social anxiety", "Loneliness", "Mate value", "Attraction to children", "Speed", "DUI", "Rob", "Kill", "Prostitute", "Rape", "Zoophilia", "Public porn", "Porn child", "Porn child darknet", "Chat child", "Gift child", "Sex child")
rownames(corr_mat_m) <- colnames(corr_mat_m)
ggcorrplot::ggcorrplot(corr_mat_m, hc.order=T, outline.col="white", legend.title="Correlation", colors=c("#0072B2", "white", "#D55E00")) +
labs(x="", y="") +
theme_classic() +
theme(axis.text.x=element_text(angle=50, hjust=1, size=9,
face = c(rep("bold", 3), rep('plain', 4), "bold", rep('plain', 5),
rep("bold", 4), rep("plain", 4))),
axis.text.y=element_text(face = c(rep("bold", 3), rep('plain', 4), "bold", rep('plain', 5),
rep("bold", 4), rep("plain", 4))))
data_f <- haven::read_spss("./data/dataE_2112.sav") %>% dplyr::select(CASE, gender, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr, starts_with("Y") & ends_with("r") & !ends_with("YP_r")) %>% filter(gender == 1) %>% dplyr::select(-gender)
# creating correlation matrix
corr_mat_f <- round(cor(data_f %>% select(-CASE), method="spearman"), 2)
colnames(corr_mat_f) <- c("Sex drive", "Compulsive sex.", "Probl. porn use", "Mating effort", "Social anxiety", "Loneliness", "Mate value", "Attraction to children", "Speed", "DUI", "Rob", "Kill", "Prostitute", "Rape", "Zoophilia", "Public porn", "Porn child", "Porn child darknet", "Chat child", "Gift child", "Sex child")
rownames(corr_mat_f) <- colnames(corr_mat_f)
ggcorrplot::ggcorrplot(corr_mat_f, hc.order=T, outline.col="white", legend.title="Correlation", colors=c("#0072B2", "white", "#D55E00")) +
labs(x="", y="") +
theme_classic() +
theme(axis.text.x=element_text(angle=50, hjust=1, size=9,
face = c(rep("bold", 5), rep('plain', 2), "bold", rep('plain', 11),
rep("bold", 2))),
axis.text.y=element_text(face = c(rep("bold", 5), rep('plain', 2), "bold", rep('plain', 11),
rep("bold", 2))))
data <- haven::read_spss("./data/dataE_2112.sav") %>% dplyr::select(CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr, starts_with("Y") & ends_with("r") & !ends_with("YP_r"))
# creating correlation matrix
corr_mat <- round(cor(data %>% select(-CASE), method="spearman"), 2)
#p.mat <- ggcorrplot::cor_pmat(data %>% select(-CASE)) #if we want to include p values
colnames(corr_mat) <- c("Sex drive", "Compulsive sex.", "Probl. porn use", "Mating effort", "Social anxiety", "Loneliness", "Mate value", "Attraction to children", "Speed", "DUI", "Rob", "Kill", "Prostitute", "Rape", "Zoophilia", "Public porn", "Porn child", "Porn child darknet", "Chat child", "Gift child", "Sex child")
rownames(corr_mat) <- colnames(corr_mat)
ggcorrplot::ggcorrplot(corr_mat, hc.order=T, outline.col="white", legend.title="Correlation", colors=c("#0072B2", "white", "#D55E00")
#, p.mat = p.mat, insig="blank"
) +
labs(x="", y="") +
theme_classic() +
theme(axis.text.x=element_text(angle=50, hjust=1, size=9,
face = c(rep('bold', 2), rep("plain", 4), rep('bold', 2),
rep("plain", 4), "bold", rep("plain", 2), rep("bold", 2),
rep("plain", 2), "bold", "plain")),
axis.text.y=element_text(face = c(rep('bold', 2), rep("plain", 4), rep('bold', 2),
rep("plain", 4), "bold", rep("plain", 2), rep("bold", 2),
rep("plain", 2), "bold", "plain")))
