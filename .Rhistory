View(data_females)
data_females <- haven::read_spss("./data/data raw/dataE_2112.sav") %>% dplyr::select(gender, CASE, sexdrive2, CSBD, PPCS_6, meffort, socialanx, lon, mvalue, attr) %>% filter(gender == 1) %>% dplyr::select(-gender)
f_factor <- lapply(data_females %>% select(-CASE, -attr, -CSBD, -PPCS_6),cut_number, n=4) %>% as.tibble()
f_factor <- lapply(f_factor, ordered) %>% as.tibble()
data_females <- cbind(data_females$CASE, f_factor, data_females$attr) %>% mutate(attr  = case_when(`data_females$attr` == 0 ~ "no attraction", `data_females$attr` > 0 ~ "some attraction"), CSBD = data_females$CSBD, PPCS_6 = data_females$PPCS_6)
data_females <- data_females %>% select(-`data_females$attr`)
data_females <- data_females %>% mutate(attr = attr %>% ordered())
colnames(data_females)[1]<-"CASE"
data_females <- data_females %>% mutate(PPCS_6 = cut_number(data_females$PPCS_6, n=2) %>% ordered(), CSBD = cut_number(data_females$CSBD, n=2) %>% ordered())
View(data_females)
desc_m <- tidySEM::descriptives(data_males %>% select(-CASE))
desc_m <- desc_m %>% select(name, type, n, missing, unique, mode, mode_value, v)
desc_f <- tidySEM::descriptives(data_males %>% select(-CASE))
desc_f <- desc_m %>% select(name, type, n, missing, unique, mode, mode_value, v)
deesc_m
desc_m
desc_f
desc_f <- tidySEM::descriptives(data_females %>% select(-CASE))
desc_f <- desc_f %>% select(name, type, n, missing, unique, mode, mode_value, v)
desc_f
lca_models_m <- mx_lca(data=data_males %>% select(-CASE), classes=1:7)
save.image("C:/Users/gniel/OneDrive - MSB Medical School Berlin/Project special issue/LPA_analysis/.RData")
lca_fit <- table_fit(lca_models_m) %>% select(Name, LL, n, Parameters, BIC, Entropy, prob_min, n_min, np_ratio, np_local)
lca_fit
BLRT_lca_m <- BLRT(lca_models_m, replications=1000)
knitr::opts_chunk$set(echo = TRUE)
BLRT_lca_m <- BLRT(lca_models_m, replications=100)
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
BLRT_lca_m <- BLRT(lca_models_m, replications=100)
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
saveRDS(lpa_model_eval, "lpa_model_eval.RDS")
saveRDS(lpa_models, "lpa_models")
saveRDS(optics_models, "optics_models.RDS")
saveRDS(full, "LPA_full_data.RDS")
rm(lpa_models)
rm(optics_models)
rm(lpa_model_eval)
rm(full)
View(desc_m)
View(lca_fit)
lr_lmr(lca_fit)
View(lca_fit)
View(lca_models_m)
lr_lmr(lca_models_m[[3]])
lca_models_m[[3]]
lca_models_m[[3]] %>% class()
?lr_lmr
lr_lmr(lca_models_m)
LR_lca_m <- lr_lmr(lca_models_m)
LR_lca_m
lca_final_model <- lca_models[[3]] #x is the class enumaration of choice
lca_final_model <- lca_models_m[[3]] #x is the class enumaration of choice
prob_table_LCA_m <- table_prob(lca_final_model)
reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category"))
plot_prob(lca_final_model_m)
lca_final_model_m <- lca_models_m[[3]] #x is the class enumaration of choice
plot_prob(lca_final_model_m)
#Check tge
table_LCA_m <- table_results(lca_final_model_m)
table_LCA_m
#class proportions
class_prob_lca_m <- class_prob(lca_final_model_m, "sum.posterior")
class_prob_lca_m
view(lca_fit)
View(data_males)
data_males %>% select(-CASE) %>% table()
view(desc_m)
prob_table_LCA_m <- table_prob(lca_final_model_m)
reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category")) %>% view()
scipen(999)
options(scipen=999)
reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category")) %>% view()
plot_prob(lca_final_model_m)
lca_models_f <- mx_lca(data=data_females %>% select(-CASE), classes=1:7)
lca_fit_f <- table_fit(lca_models_f) %>% select(Name, LL, n, Parameters, BIC, Entropy, prob_min, n_min, np_ratio, np_local)
LR_lca_f <- lr_lmr(lca_models_f)
lca_fit_f
view(lca_fit_f)
#Check tge
table_LCA_f <- table_results(lca_final_model_f)
lca_final_model_f <- lca_models_f[[3]] #x is the class enumaration of choice
#Check tge
table_LCA_f <- table_results(lca_final_model_f)
#Check tge
table_LCA_f <- table_results(lca_final_model_f)
prob_table_LCA_f <- table_prob(lca_final_model_f)
reshape(prob_table_LCA_f, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category")) %>% view()
plot_prob(lca_final_model_f)
#class proportions
class_prob_lca_f <- class_prob(lca_final_model_m, "sum.posterior")
class_prob_lca_f
table_LCA_f
LR_lca_f
save.image("C:/Users/gniel/OneDrive - MSB Medical School Berlin/Project special issue/LPA_analysis/.RData")
View(desc_m)
View(desc_f)
View(data_females)
View(desc_m)
knitr::opts_chunk$set(echo = TRUE)
desc_m
desc_f
lca_fit
rmarkdown::render("LCA_analysis.Rmd")
save.image("C:/Users/gniel/OneDrive - MSB Medical School Berlin/Project special issue/LPA_analysis/.RData")
getwd()
load(".RData")
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
lca_fit <- table_fit(lca_models_m) %>% select(Name, LL, n, Parameters, BIC, Entropy, prob_min, prob_max, n_min, np_ratio, np_local)
lca_fit
?LRT
?lr_lmr
View(lca_models_m)
lr_lmr(lca_models_m)
attributes(lr_lmr(lca_models_m))
view(lr_lmr)
lr_lmr
tidySEM::lr_lmr
??tidySEM::lr_lmr
getMethod("tidySEM", ""lr_lmr)
getMethod("tidySEM", "lr_lmr)
getMethod("tidySEM", "lr_lmr")
getMethod("lr_lmr", "tidySEM")
showMethods("lr_lmr")
lr_test(lca_models_m)
lr_lmr(lca_models_m)
View(lca_models_m)
nonnest2::vuongtest(lca_final_model_m[[2]], lca_final_model[[3]])
nonnest2::vuongtest(lca_final_models_m[[2]], lca_models_m[[3]])
nonnest2::vuongtest(lca_models_m[[2]], lca_models_m[[3]])
nonnest2::vuongtest(lca_models_m$1, lca_models_m$2)
lca_models_m$"1"
lca_models_m
lca_models_m[[2]] %>% class()
nonnest2::vuongtest(lca_models_m[[2]],lca_final_model_m[[3]], nested=FALSE)
nonnest2::vuongtest(lca_models_m[["2"]],lca_final_model_m[["3"]], nested=FALSE)
nonnest2::vuongtest(lca_models_m[[2]],lca_final_model_m[[3]], nested=FALSE)
lca_models_m[[2]] %>% class()
test1 <- lca_models_m[[2]]
test2 <- lca_models_m[[3]]
nonnest2::vuongtest(test1, test2)
nonnest2::vuongtest(test1, test2,source1 = function(x)mixgrads(x) * -.5, source2 = function(x)mixgrads(x) * -.5, nested=FALSE)
?nonnest::vuongtest()
library(nonnest2)
?vuongtest
nonnest2::vuongtest(test1, test2, score1 = function(x)mixgrads(x) * -.5, score2 = function(x)mixgrads(x) * -.5, nested=FALSE)
library(OpenMx)
nonnest2::vuongtest(test1, test2, score1 = function(x)mixgrads(x) * -.5, score2 = function(x)mixgrads(x) * -.5, nested=FALSE)
?mixgrads
??mixgrads
mixgrads <- function(model){
if(!isTRUE("mixture" %in% attr(model, "tidySEM")) & length(names(model@submodels)) > 1){
return(imxRowGradients(model))
}
paramLabels <- names(omxGetParameters(model))
numParam <- length(paramLabels)
custom.compute <-
mxComputeSequence(list(
mxComputeNumericDeriv(checkGradient = FALSE,
hessian = FALSE),
mxComputeReportDeriv()
))
grads <- do.call(rbind, lapply(1:nrow(model@data$observed), function(i) {
tryCatch({
mxRun(mxModel(model, custom.compute, mxData(model@data$observed[i, , drop = FALSE], "raw")), silent = TRUE)$output$gradient
},
error = function(e) {
rep(NA, length(numParam))
})
}))
return(grads)
}
nonnest2::vuongtest(test1, test2, score1 = function(x)mixgrads(x) * -.5, score2 = function(x)mixgrads(x) * -.5, nested=FALSE)
nonnest2::vuongtest(test1, test2, nested=FALSE)
view(nonnest2::vuongtest())
view(nonnest2::vuongtest
)
View(LR_lca_m)
?tablefit()
?table_fit
class_ prob(lca_fit, type = “sum.posterior”)
class_prob(lca_fit, type = “sum.posterior”)
class_prob(lca_fit, type = "sum.posterior")
class_prob(lca_final_model_m, type = "sum.posterior")
class_prob(lca_final_model_m, type = "sum.most_likely")
class_prob(lca_final_model_m, type = "sum.mostlikely")
class_prob(lca_final_model_m, type="avg.mostlikely")
?plot_prob
plot_prob(lca_final_model_m)
reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category")) %>% view()
?table_prob
(0.2/(1-0.2)/(0.48/(1-0.48))
(0.2/(1-0.2))/(0.48/(1-0.48))
install.packages(distributionsrd)
install.packages("distributionsrd")
attributes(test1)
lca_fit
test_1_parameters <- lca_fit$LL[2]
test_2_parameters <- lca_fit$LL[3]
test_1_ll <- lca_fit$LL[2]
test_2_ll <- lca_fit$LL[3]
distributionsrd::llr_vuong(test_1_ll, test_2_ll, 45, 68)
view(distributionsrd::llr_vuong(test_1_ll, test_2_ll, 45, 68))
test_1_ll <- lca_fit$LL[1]
test_2_ll <- lca_fit$LL[2]
test_1_ll <- lca_fit$LL[1]
test_2_ll <- lca_fit$LL[2]
llr_vuong(test_1_ll, test_2_ll, 22, 45)
distributionsrd::llr_vuong(test_1_ll, test_2_ll, 22, 45)
distributionsrd::llr_vuong(test_1_ll, test_2_ll, 22, 45) %>% view()
rlnorm(1e4, meanlog = -0.5, sdlog = 0.5)
x <- rlnorm(1e4, meanlog = -0.5, sdlog = 0.5)
pareto_fit <- combdist.mle(x = x, dist = "pareto")
?vuongtest
?llr_vuong
?vuongtest
?llr_vuong
view(test_1_ll)
view(llr_vuong)
view({distributionsrd::llr_vuong)
view(distributionsrd::llr_vuong)
attributes(lca_final_model_m)
attributes(lca_final_model_m) %>% class()
attributes(lca_final_model_m) %>% names()
lca_final_model_m$output %>% class()
lca_final_model_m$output %>% names()
lca_final_model_m$output$Minus2LogLikelihood
lca_final_model_m$output$matrices %>% class()
lca_final_model_m$output$matrices %>% names()
lca_final_model_m$output$algebras
lca_final_model_m$output$algebras %>% names()
lca_final_model_m$output %>% names()
lca_final_model_m$output$expectations %>% names()
lca_final_model_m$output$fit %>% names()
lca_final_model_m$output$vcov %>% names()
lca_final_model_m$output$vcov
data$sex_drive %>% unique()
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
data$sex_drive %>% unique()
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
View(data)
View(data_males)
data_males$sexdrive2 %>% unique()
data_males$sexdrive2 %>% hist()
data_males$sexdrive2 %>% table()
496+179+300+288
prob_table_LCA_m <- reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category")) %>% view()
plot(lca_fit)
fit(lca_models_m) %>% colnames()
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
fit(lca_models_m) %>% colnames()
tidySEM::fit(lca_models_m) %>% colnames()
tidySEM::table_fit(lca_models_m) %>% colnames()
lca_fit <- table_fit(lca_models_m) %>% select(Name, LL, n, Parameters, BIC, saBIC, Entropy, prob_min, prob_max, n_min, np_ratio, np_local)
lca_fit_f <- table_fit(lca_models_f) %>% select(Name, LL, n, Parameters, BIC, saBIC, Entropy, prob_min, prob_max, n_min, np_ratio, np_local)
lca_fit
lca_fit <- table_fit(lca_models_m) %>% select(Name, LL, n, Parameters, BIC, Entropy, prob_min, prob_max, n_min, np_ratio, np_local)
lca_fit_f <- table_fit(lca_models_f) %>% select(Name, LL, n, Parameters, BIC, Entropy, prob_min, prob_max, n_min, np_ratio, np_local)
View(prob_table_LCA_m)
prob_table_LCA_m <- reshape(prob_table_LCA_m, direction="wide", v.names="Probability", timevar="group", idvar = c("Variable", "Category"))
View(prob_table_LCA_m)
class_prob(lca_final_model_m, type="avg.mostlikely")
prob_table_LCA_m
options(scipen = 999)
prob_table_LCA_m
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
options(scipen = 999)
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
options(scipen = 999)
lca_final_model_m$fitfunction$vector
lca_final_model_m$fitfunction$rowwiseParallel
lca_final_model_m$fitfunction
lca_final_model_m$expectation$data
lca_final_model_m$expectation
lca_final_model_m$data
lca_final_model_m$output
lca_final_model_m$output$expectations
lca_final_model_m$output$algebras$mix3.fitfunction
lca_final_model_m$output$algebras$class1.fitfunction
test <- lca_final_model_m$output$algebras$class1.fitfunction
View(test)
test <- tibble(class_1 = lca_final_model_m$output$algebras$class1.fitfunction, class_2 = lca_final_model_m$output$algebras$class2.fitfunction, class_3 = lca_final_model_m$output$algebras$class3.fitfunction)
lca_final_model_m$output$algebras$class1.fitfunction %>% class()
lca_final_model_m$output$algebras$class1.fitfunction %>% str()
lca_final_model_m$output$algebras$mix3.fitfunction %>% str()
View(lca_fit)
11892.55/-2
lca_final_model_m$output$algebras$class1.Thresholds
lca_final_model_m$output$fit
lca_final_model_m$output$algebras$mix3.fitfunction
-2*log10(23785.09)
lca_final_model_m %>% estimate_lavaan()
get_fit(lca_models_m)
attr(mxEval(class1.fitfunction, lca_final_model_m), 'likelihoods')
??llr_vuong
wgts <- lca_final_model_m$expectation$output$weights
lc3 <- attr(mxEval(class3.fitfunction, lca_final_model_m), 'likelihoods')
lc2 <- attr(mxEval(class2.fitfunction, lca_final_model_m), 'likelihoods')
cc <- cbind(l1=lc1*wgts[1],
l2=lc2*wgts[2],
l3=lc3*wgts[3])
lc1 <- attr(mxEval(class1.fitfunction, lca_final_model_m), 'likelihoods')
cc <- cbind(l1=lc1*wgts[1],
l2=lc2*wgts[2],
l3=lc3*wgts[3])
ll_final <- log(rowsum(cc))
rowsum(cc)
View(cc)
ll_final <- log(rowSums(cc))
view(ll_final)
lc1 <- attr(mxEval(class1.fitfunction, lca_models_m[[4]]), 'likelihoods')
lc2 <- attr(mxEval(class2.fitfunction, lca_models_m[[4]]), 'likelihoods')
lc3 <- attr(mxEval(class3.fitfunction, lca_models_m[[4]]), 'likelihoods')
lc4 <- attr(mxEval(class4.fitfunction, lca_models_m[[4]]), 'likelihoods')
wgts <- lca_models_m[[4]]$expectation$output$weights
cc <- cbind(l1=lc1*wgts[1],
l2=lc2*wgts[2],
l3=lc3*wgts[3],
l4=lc4*wgts[4])
ll_4<- log(rowSums(cc))
View(lca_fit)
distributionsrd::llr_vuong(ll_final, ll_4, 68, 91)
test_lr <- distributionsrd::llr_vuong(ll_final, ll_4, 68, 91)
View(test2)
View(test_lr)
distributionsrd::llr_vuong %>% view()
??vuong
nonnest2::vuongtest(ll1=ll_final, ll2=ll_4)
nonnest2::vuongtest(lca_final_model, lca_models_m[[4]],ll1=ll_final, ll2=ll_4)
nonnest2::vuongtest(lca_final_model, lca_models_m[[4]],ll1=ll_final, ll2=ll_4)
view(nonnest2::vuongtest)
view(lr_lmr)
lca_final_model_m$output$algebras %>% names()
library(tidyverse)
lca_final_model_m$output$algebras %>% names()
lca_final_model_m$output$algebras %>% names() %>% str_detect(".fitfunction")
lca_final_model_m$output$algebras %>% names() %>% str_extract_all(".fitfunction")
lca_final_model_m$output$algebras %>% names() %>% str_subset(".fitfunction")
lca_final_model_m$output$algebras %>% names() %>% str_subset(".fitfunction") %>% str_subset("class")
lca_final_model_m$output$algebras %>% class()
lca_final_model_m$output$algebras[["class1.fitfunction"]]
lca_final_model_m$output$algebras[["class1.fitfunction"]]$vector
lca_final_model_m$expectation$output %>% names()
lca_final_model_m$expectation$output$weights
get_likelihood_vector <- function(x){
#Get names of likelihood vectors
clv_names <- x$output$algebras %>%
names() %>%
str_subset(".fitfunction") %>%
str_subset("class")
clv <- list()
for(i in 1:length(clv_names)){
clv[[clv_names[i]]] <- x$output$algebras[[clv_names[i]]]*x$expectation$output$weights[i]
}
clv <- as.data.frame(do.call(cbind, clv))
return(log(rowSums(clv)))
}
get_likelihood_vector(lca_final_model_m)
get_likelihood_vector(lca_final_model_m) %>% class()
nonnest2::llr_vuong(lca_final_model_m, lca_models_m[[4]], ll1 = get_likelihood_vector, ll2 = get_likelihood_vector)
nonnest2::vuongtest(lca_final_model_m, lca_models_m[[4]], ll1 = get_likelihood_vector, ll2 = get_likelihood_vector)
nonnest2::vuongtest(lca_final_model_m, lca_models_m[[4]], ll1 = get_likelihood_vector, ll2 = get_likelihood_vector, adj="BIC")
nonnest2::vuongtest(lca_final_model_m, lca_models_m[[4]], ll1 = get_likelihood_vector, ll2 = get_likelihood_vector, adj="bic")
eigen(get_likelihood_vector(lca_final_model))
traceback(eigen(get_likelihood_vector(lca_final_model)))
nonnest2::vuongtest(lca_final_model_m, lca_models_m[[4]], ll1 = get_likelihood_vector, ll2 = get_likelihood_vector, adj="bic") %>% traceback()
lca_final_model_m$latentVars
distributionsrd::llr_vuong(get_likelihood_vector(lca_final_model_m), get_likelihood_vector(lca_models_m[[4]]), 68, 91) %>% view()
lca_final_model_m
lca_final_model_m$weights
lca_final_model_m$output$estimate
data_males$attr %>% table()
52/1263
class_prob(lca_final_model_m, "sum.posterior")
knitr::opts_chunk$set(echo = TRUE)
#for reproduceable results
set.seed(42)
#Declare vector of required packages
packages <- c("tidyverse", "readr", "tidySEM", "rio", "ggpubr")
#load function to check whether required packages are installed.
source("./functions/check_required_packages.R")
check_required_packages(packages)
#load required packages
lapply(packages, require, character.only=T)
#######ATTENTION:
#At this point I load a presaved RData variables in which the  environment is saved. That makes the code less reproduceable, but removing the eval=FALSE specifications in all code blocks will make that possible.
load(".RData")
#turn off scientific notification
options(scipen = 999)
class_prob(lca_final_model_m, "sum.posterior")
381+313+567
load("C:/Users/gniel/OneDrive - MSB Medical School Berlin/Project special issue/LPA_analysis/.RData")
source("./functions/D_matrix_modal.R")
source(".functions/modal_weights")
source("./functions/modal_weights")
source("./functions/modal_weights.R")
#First extract posterior probabilities for class assignment and most likely class membership
posteriors <- class_prob(lca_final_model_m, type="individual")$individual %>% as_tibble()
library(tidyverse)
library(tidySEM)
#First extract posterior probabilities for class assignment and most likely class membership
posteriors <- class_prob(lca_final_model_m, type="individual")$individual %>% as_tibble()
#Compute the inverse D matrix as in Bakk et al. (2013)
inverse_D <- solve(D_matrix_modal(posteriors))
#Extract a vector with the most likely class memberships
modal_assignments <- posteriors %>% select(predicted)
#Use the modal_weights function to create modal weights from the inverse_D matrix and combine the results in a tibble with the posterior probabilities of class membership and the most likely class membership.
BCH_expanded_dataframe <- tibble(posteriors, modal_weights(modal_assignments, inverse_D) %>% as_tibble())
colnames(BCH_expanded_dataframe) <- c("postprob_class_1", "postprob_class_2", "postprob_class_3", "modal_class", "modal_weight_1", "modal_weight_2", "modal_weight_3")
#Tidy up behind us
rm(modal_assignments, inverse_D, posteriors)
BCH_expanded_dataframe
data_males %>% nrow()
data_males %>% select(CASE)
data_males %>% colnames()
#Attach the CASE variable to our weighted dataframe.
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% mutate(CASE = data_males$CASE)
View(BCH_expanded_dataframe)
View(BCH_expanded_dataframe)
BCH_expanded_dataframe %>% pivot_longer(cols=starts_with("modal_weight")) %>% view()
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% pivot_longer(cols=starts_with("modal_weight"), values_to = "modal_weight", names_to=NULL)
View(BCH_expanded_dataframe)
#First extract posterior probabilities for class assignment and most likely class membership
posteriors <- class_prob(lca_final_model_m, type="individual")$individual %>% as_tibble()
#Compute the inverse D matrix as in Bakk et al. (2013)
inverse_D <- solve(D_matrix_modal(posteriors))
#Extract a vector with the most likely class memberships
modal_assignments <- posteriors %>% select(predicted)
#Use the modal_weights function to create modal weights from the inverse_D matrix and combine the results in a tibble with the posterior probabilities of class membership and the most likely class membership.
BCH_expanded_dataframe <- tibble(posteriors, modal_weights(modal_assignments, inverse_D) %>% as_tibble())
colnames(BCH_expanded_dataframe) <- c("postprob_class_1", "postprob_class_2", "postprob_class_3", "modal_class", "modal_weight_1", "modal_weight_2", "modal_weight_3")
#Tidy up behind us
rm(modal_assignments, inverse_D, posteriors)
#Attach the CASE variable to our weighted dataframe.
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% mutate(CASE = data_males$CASE)
View(BCH_expanded_dataframe)
vec_rep(1:3, nrow(BCH_expanded_dataframe))
vctrs::vec_rep(1:3, nrow(BCH_expanded_dataframe))
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% pivot_longer(cols=starts_with("modal_weight"), values_to = "modal_weight", names_to=NULL)
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% mutate(predicted_class = vctrs::vec_rep(1:3, nrow(BCH_expanded_dataframe)))
BCH_expanded_dataframe <- BCH_expanded_dataframe %>% mutate(predicted_class = vctrs::vec_rep(1:3, nrow(data_males)))
View(BCH_expanded_dataframe)
fastDummies::dummy_cols(BCH_expanded_dataframe, select_columns = "predicted_class")
#Create dummy variables from this variable
BCH_expanded_dataframe <- fastDummies::dummy_cols(BCH_expanded_dataframe, select_columns = "predicted_class")
View(BCH_expanded_dataframe)
